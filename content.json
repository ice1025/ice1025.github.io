[{"title":"springMVC常用注解之@Controller @RequestMapping","date":"2017-10-12T03:04:00.864Z","path":"2017/10/12/springMVC-3/","text":"@Controller@controller负责注册一个bean 到spring 上下文中，注解表明一个类是作为控制器的角色存在，spring不要求你去继承任何控制器基类，也不要求你去实现Servlet的那套api。@controller注解表明这个类所承担的角色，分派器（DispatcherServlet）会扫描所有注解了@Controller的类，检测其中通过@RequestMapping注解配置的方法。当然，你也可以不使用@Controller注解而显式地去定义被注解的bean，这点通过标准的Spring bean的定义方式，在dispather的上下文属性下配置即可做到。但是@Controller原型是可以被框架自动检测的，Spring支持classpath路径下组件类的自动检测，以及对已定义bean的自动注册。1234&lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt; &lt;context:component-scan base-package=\"controller\" /&gt; &lt;!-- 配置注解驱动 --&gt; &lt;mvc:annotation-driven/&gt; @RequestMappingRequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。RequestMapping注解有六个属性，下面我们把它分成三类进行说明。 value， methodvalue： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）method： 指定请求的method类型， GET、POST、PUT、DELETE等 consumes，producesconsumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/htmlproduces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回 params，headersparams： 指定request中必须包含某些参数值时，才让该方法处理。headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。 示例： 1、value / method 示例默认RequestMapping(“….str…”)即为value的值；1234567891011121314151617181920212223242526272829303132333435@Controller @RequestMapping(\"/appointments\") public class AppointmentsController &#123; private final AppointmentBook appointmentBook; @Autowired public AppointmentsController(AppointmentBook appointmentBook) &#123; this.appointmentBook = appointmentBook; &#125; @RequestMapping(method = RequestMethod.GET) public Map&lt;String, Appointment&gt; get() &#123; return appointmentBook.getAppointmentsForToday(); &#125; @RequestMapping(value=\"/&#123;day&#125;\", method = RequestMethod.GET) public Map&lt;String, Appointment&gt; getForDay(@PathVariable @DateTimeFormat(iso=ISO.DATE) Date day, Model model) &#123; return appointmentBook.getAppointmentsForDay(day); &#125; @RequestMapping(value=\"/new\", method = RequestMethod.GET) public AppointmentForm getNewForm() &#123; return new AppointmentForm(); &#125; @RequestMapping(method = RequestMethod.POST) public String add(@Valid AppointmentForm appointment, BindingResult result) &#123; if (result.hasErrors()) &#123; return \"appointments/new\"; &#125; appointmentBook.addAppointment(appointment); return \"redirect:/appointments\"; &#125; &#125; value的uri值为以下三类：A） 可以指定为普通的具体值；B) 可以指定为含有某变量的一类值；C) 可以指定为含正则表达式的一类值； example B)12345public String findOwner(@PathVariable String ownerId,Model model)&#123; Owner owner = ownerService.findOwner(ownerId); model.addAttribute(\"owner\", owner); return \"displayOwner\"; &#125; example C)12345@RequestMapping(\"/spring-web/&#123;symbolicName:[a-z-]+&#125;-&#123;version:\\d\\.\\d\\.\\d&#125;.&#123;extension:\\.[a-z]&#125;\") public void handle(@PathVariable String version, @PathVariable String extension) &#123; // ... &#125; &#125; 2、 consumes、produces 示例cousumes的样例：12345@Controller @RequestMapping(value = \"/pets\", method = RequestMethod.POST, consumes=\"application/json\") public void addPet(@RequestBody Pet pet, Model model) &#123; // implementation omitted &#125; 方法仅处理request Content-Type为“application/json”类型的请求。 produces的样例：123456@Controller @RequestMapping(value = \"/pets/&#123;petId&#125;\", method = RequestMethod.GET, produces=\"application/json\") @ResponseBody public Pet getPet(@PathVariable String petId, Model model) &#123; // implementation omitted &#125; 方法仅处理request请求中Accept头中包含了”application/json”的请求，同时暗示了返回的内容类型为application/json; 3、 params、headers 示例params的样例：1234567891011121314151617181920212223@Controller @RequestMapping(\"/owners/&#123;ownerId&#125;\") public class RelativePathUriTemplateController &#123; @RequestMapping(value = \"/pets/&#123;petId&#125;\", method = RequestMethod.GET, params=\"myParam=myValue\") public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) &#123; // implementation omitted &#125; &#125; ``` 仅处理请求中包含了名为“myParam”，值为“myValue”的请求；headers的样例：```java@Controller @RequestMapping(\"/owners/&#123;ownerId&#125;\") public class RelativePathUriTemplateController &#123; @RequestMapping(value = \"/pets\", method = RequestMethod.GET, headers=\"Referer=http://www.imice.me/\") public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) &#123; // implementation omitted &#125; &#125; 仅处理request的header中包含了指定“Refer”请求头和对应值为http://www.imice.me/的请求； 上面仅仅介绍了，RequestMapping指定的方法处理哪些请求，下面一篇将讲解怎样处理request提交的数据（数据绑定）和返回的数据。","tags":[{"name":"springMVC","slug":"springMVC","permalink":"http://imice.me/tags/springMVC/"}]},{"title":"CentOS安装配置jdk","date":"2017-09-04T06:52:18.131Z","path":"2017/09/04/CentOS_jdk1.7/","text":"CentOS：6.9 x64jdk：1.7 查看是否安装有jdk，并删除之前版本1234#查看rpm -qa|grep java#删除rpm -e --nodeps java-XXXX 从官网下载好1.7的安装包，解压到指定目录/usr/local/java12tar zxvf jdk-7u79-linux-x64.tar.gz -C /usr/local/java/#当前目录结构为 /usr/local/java/jdk1.7.0_79 配置环境变量，编辑/etc/prodile文件12345vim /etc/profile#在末尾添加export JAVA_HOME=/usr/local/java/jdk1.7.0_79export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$PATH:$JAVA_HOME/bin 重新加载/etc/profile1souce /etc/profile 查看12345java -version#显示如下java version \"1.7.0_79\"Java(TM) SE Runtime Environment (build 1.7.0_79-b15)Java HotSpot(TM) 64-Bit Server VM (build 24.79-b02, mixed mode)","tags":[{"name":"linux","slug":"linux","permalink":"http://imice.me/tags/linux/"}]},{"title":"springMVC学习记录（二）基于代码的servlet容器初始化","date":"2017-08-01T03:27:09.900Z","path":"2017/08/01/springMVC-2/","text":"IDE:：idea16构建工具：mavenjdk版本：1.7 springMVC简介 springMVC是围绕一个DispatcherServlet来设计的，这个servlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，支持文件上传。处理器是你的应用中注解了@Controller和@RequestMapping的类和方法，spring为处理器方法提供了多样灵活的配置。spring3.0以后提供了@Controller注解机制，@PathVariable注解以及一些其他的特性，你可以使用它们来进行RESTful web站点和应用的开发。 对扩展开发是spring web MVC框架的一个重要的设计原则，对整个spring框架来说，设计原则就是传说中的 对扩展开放，对修改关闭。（OCP：Open-Closed Principle）到底是啥意思呢，就是在设计一个软件系统模块（类，方法）的时候，应该可以在不修改原有的模块（修改关闭）的基础上，能扩展其功能（扩展开放）。 扩展开放：某模块的功能是可扩展的，则该模块是扩展开放的，软件系统的功能上的可扩展性要求模块是扩展开放的。 修改关闭：某模块被其他模块调用，如果该模块的源代码不允许修改，则该模块修改关闭的。软件系统的功能上的稳定性，持续性要求是修改关闭的。 DispatcherServletspring MVC框架与其他很多web的MVC框架一样，请求驱动，所有设计都围绕着一个中央Servlet来展开，它负责把所有请求分发到控制器，同时提供其他Web应用开发所需要的功能。不过spring的中央处理器DispatcherServlet能做的比这更多。它与spring IOC容器做到了无缝集成，这意味着Spring提供的任何特性，在spring MVC中你都可以使用。 这张图展示了Spring Web MVC的DispatcherServlet处理请求的工作流。熟悉设计模式的朋友会发现，DispatcherServlet应用的其实就是一个前端控制器的设计模式（其他很多优秀的web框架也都使用了这个设计模式）。 12345678910111213141516&lt;!--配置springMVC,这里的servlet名称决定着SpringMVC配置文件的名称--&gt;&lt;servlet&gt; &lt;servlet-name&gt;spring-mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动时加载,1代表优先级,越小代表越高--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;spring-mvc&lt;/servlet-name&gt; &lt;!--这里修改为全部页面--&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 上一篇环境配置中我们使用的是 在web.xml 文件中配置DispatcherServlet的方法，标准的java-EE Servlet配置，所有请求都会被名字为spring-mvc的DispatcherServlet处理。接下来我们使用基于代码配置的方法，需要在servlet 3.0环境下，我们引入123456&lt;!-- 导入java ee jar 包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; MyWebApplicationInitializer.java123456789101112public class MyWebApplicationInitializer implements WebApplicationInitializer&#123; public void onStartup(javax.servlet.ServletContext servletContext) throws ServletException &#123; XmlWebApplicationContext appConttext = new XmlWebApplicationContext(); appConttext.setConfigLocation(\"classpath:spring-mvc.xml\"); ServletRegistration.Dynamic registration = servletContext.addServlet(\"spring-mvc\",new DispatcherServlet(appConttext)); registration.setLoadOnStartup(1); registration.addMapping(\"/\"); &#125;&#125; 这个例子和上面的web.xml配置文件是等效的WebApplicationInitializer是spring MVC提供的一个接口，它会查找你所有基于代码的配置，并应用它们来初始化Servlet 3.0版本以上的web容器，它有一个抽象的实现AbstractDispatcherServletInitializer,用以简化DispatcherServlet的注册工作，你只需要指定其servlet映射(mapping)即可。 DispatcherServlet的处理流程 配置好DispatcherServlet以后，开始有请求会经过这个DispatcherServlet，此时DispatcherServlet会按照以下次序对请求进行处理 首先搜索应用的上下文对象，WebApplicationContext并把它作为一个属性（attribute）绑定到该请求上，以便控制器和其他组件能够使用它。属性的键名默认为DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE 将地区（locale）解析器绑定到请求上，以便其他组件在处理请求（渲染视图、准备数据等）时可以获取区域相关的信息。如果你的应用不需要解析区域相关的信息，忽略它即可 将主题（theme）解析器绑定到请求上，以便其他组件（比如视图等）能够了解要渲染哪个主题文件。同样，如果你不需要使用主题相关的特性，忽略它即可 如果你配置了multipart文件处理器，那么框架将查找该文件是不是multipart（分为多个部分连续上传）的。若是，则将该请求包装成一个MultipartHttpServletRequest对象，以便处理链中的其他组件对它做进一步的处理。 为该请求查找一个合适的处理器。如果可以找到对应的处理器，则与该处理器关联的整条执行链（前处理器，后处理器，控制器等）都会被执行，以完成相应模型的准备或视图的渲染 如果处理器返回的是一个模型（model），那么框架将渲染相应的视图。若没有返回任何模型（可能是因为前后的处理器出于某种原因拦截了请求等，比如安全问题），则框架不会渲染任何视图，此时认为对请求的处理可能已经由处理链完成了 如果在处理请求的过程中抛出了异常，那么上下文WebApplicationContext对象中所定义的异常处理器将会负责捕获这些异常。通过配置你自己的异常处理器，你可以定制自己处理异常的方式。 你可以定制DispatcherServlet的配置，具体的做法，是在web.xml文件中，Servlet的声明元素上添加一些Servlet的初始化参数（通过init-param元素）。该元素可选的参数列表 contextClass &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任意实现了WebApplicationContext接口的类。这个类会初始化该servlet所需要用到的上下文对象。默认情况下，框架会使用一个XmlWebApplicationContext对象。 contextConfigLocation &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个指定了上下文配置文件路径的字符串，该值会被传入给contextClass所指定的上下文实例对象。该字符串内可以包含多个字符串，字符串之间以逗号分隔，以此支持你进行多个上下文的配置。在多个上下文中重复定义的bean，以最后加载的bean定义为准 namespace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WebApplicationContext的命名空间。默认是[servlet-name]-servlet","tags":[{"name":"springMVC","slug":"springMVC","permalink":"http://imice.me/tags/springMVC/"}]},{"title":"springMVC学习记录（一）环境搭建","date":"2017-07-31T09:29:42.862Z","path":"2017/07/31/springMVC-1/","text":"以前没有写博客记录的习惯，发现好多东西写过之后特别容易忘，最近有点时间，重新回顾一下，恩…从springMVC开始 IDE:：idea16构建工具：mavenjdk版本：1.7 使用idea创建maven项目 创建过程比较简单，放几张图 next 继续next 这里maven home可以选择 idea默认提供的，也可以指定自己的maven目录 finish项目构建完成 默认生成的目录结构，以及pom文件，可以看到这里给我们默认引入了junit包配置一下我们的tomcat，点击edit 我们创建添加一个tomcat 简单配置一下 启动项目 传图片好累。。终于看到了传说中的hello world，接下来就是配置springMVC配置springMVC 引入spring的相关jar包，jstl标签 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!-- spring核心包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- JSTL标签类 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; 配置xml文件 (1)spring配置文件 applicationContext.xml1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;/beans&gt; (2)springMVC配置文件 spring-mvc.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:task=\"http://www.springframework.org/schema/task\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd\"&gt; &lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt; &lt;context:component-scan base-package=\"controller\" /&gt; &lt;!-- 配置注解驱动 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!--静态资源映射--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--设置字符编码--&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\"&gt; &lt;property name=\"messageConverters\"&gt; &lt;list&gt; &lt;bean class=\"org.springframework.http.converter.ByteArrayHttpMessageConverter\"/&gt; &lt;ref bean=\"stringHttpMessageConverter\"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"stringHttpMessageConverter\" class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\"&gt; &lt;list&gt; &lt;value&gt;text/plain;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义跳转的文件的前后缀 ，视图模式配置--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!--可以使用jstl标签--&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt;&lt;/beans&gt; (3) web.xml文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"&gt; &lt;!--指定spring的配置文件所在的目录--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--设置spring监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--配置springMVC,这里的servlet名称决定着SpringMVC配置文件的名称--&gt; &lt;servlet&gt; &lt;servlet-name&gt;spring-mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动时加载,1代表优先级,越小代表越高--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring-mvc&lt;/servlet-name&gt; &lt;!--这里修改为全部页面--&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;!--设置你想用的字符集，我这里用的是UTF-8--&gt; &lt;/init-param&gt; &lt;!--强制使用该编码--&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;!--设置你想过滤的页面或者是Servlet，根据自己的需要配置--&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 主要是配置一下视图解析，静态资源映射，编码这么些东西看下我们现在的目录结构 编写测试代码 我们在controller下新建一个HelloController，跳转到 jsp 下的hello.jspHelloController1234567891011121314package controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controllerpublic class HelloController &#123; @RequestMapping(value = \"/hello\",method = RequestMethod.GET) public String hello()&#123; return \"hello\"; &#125;&#125; hello.jsp12345678910&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; this is hello.jsp&lt;img src=\"../../static/images/05.jpg\"&gt;&lt;/body&gt;&lt;/html&gt; 引入了一张图片测试下静态资源引入是否正常，访问tomcat 到这里springMVC的简单配置就完成了，下一篇继续深入探讨","tags":[{"name":"springMVC","slug":"springMVC","permalink":"http://imice.me/tags/springMVC/"}]},{"title":"elasticSearch  Query DSL(Filters)","date":"2017-05-05T08:53:53.303Z","path":"2017/05/05/elasticsearch_queryDSL/","text":"在一篇中我们实现了mysql数据实时同步至elasticSearch，接下来就是利用java API来实现数据查询，使用Filters方式查询注释写的很清楚，包含分页，关键字查询，范围查询等等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101@RequestMapping(value = \"/testList/&#123;page&#125;\") public List&lt;Test&gt; list(HttpServletRequest request,@PathVariable(\"page\") Integer pageNo) throws ParseException &#123; int pageSize = 5; TransportClient client = EsUtil.getTransportClient(); SearchRequestBuilder srb = client.prepareSearch().setIndices(\"test\").setTypes(\"testInfo\"); /** * 有两种查询方式，query查询和filter查询 * 两者的区别： * query查询会计算一个分值，es中索引的数据都会存储一个_score分值，分值越高就代表越匹配 * filter查询不会去计算任何分值，也不关心返回的排序问题，因此效率会高一点。 * 经常使用过滤器，ES会自动的缓存过滤器的内容，这对于查询来说，会提高很多性能。 */ BoolFilterBuilder boolFilter = FilterBuilders.boolFilter(); /** * 通配符查询 查询name中带有 \"小\" 的 * * 匹配任意字符串 ? 匹配任意一个字符 */ boolFilter.must(FilterBuilders.queryFilter(QueryBuilders.wildcardQuery(\"name\",\"*小*\"))); /** * name 查询没有字段或没有值或值为null的数据 */ boolFilter.must(FilterBuilders.missingFilter(\"name\")); /** * 查询 name 不为null的数据 */ boolFilter.must(FilterBuilders.existsFilter(\"name\")); /** * idsFilter 查询 testInfo 中 id 为1 和 2 的， * \"testInfo\"为可变参数 */ boolFilter.must(FilterBuilders.idsFilter(\"testInfo\").addIds(\"1\",\"2\")); /** * 查询age等于22 或者 33 */ boolFilter.must(FilterBuilders.inFilter(\"age\",\"20\",\"33\")); /** * 查询name 等于 \"小明\" 的 */ boolFilter.must(FilterBuilders.termFilter(\"name\",\"小明\")); /** * 查询 createDate 在某个区间内 */ String date1 = \"2017-05-04 10:20:00\"; String date2 = \"2017-05-04 10:30:00\"; Date startDate = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").parse(date1); Date endDate = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").parse(date2); boolFilter.must(FilterBuilders.rangeFilter(\"createDate\").from(startDate.getTime())); boolFilter.must(FilterBuilders.rangeFilter(\"createDate\").to(endDate.getTime())); SearchResponse searchResponse = srb.setPostFilter(boolFilter) //pageNo .setFrom(pageNo&gt;0?((pageNo-1)*pageSize):0) //pageSize .setSize(pageSize) //按 id 倒序 .addSort(\"id\", SortOrder.DESC) .execute().actionGet(); SearchHits hits = searchResponse.getHits(); //总记录数 long total = hits.getTotalHits(); System.out.println(\"总记录数：\" + total); SearchHit[] searchHits = hits.hits(); List&lt;Test&gt; list = new ArrayList&lt;Test&gt;(); for (int i = 0; i &lt; searchHits.length; i++) &#123; Map&lt;String,Object&gt; map= searchHits[i].getSource(); Test t = this.recoreEntity(map); list.add(t); &#125; return list; &#125; /** * 查询结果映射为对应的实体 */ public Test recoreEntity(Map&lt;String,Object&gt; map)&#123; Calendar calendar = Calendar.getInstance(); Test test = new Test(); for (String key : map.keySet()) &#123; if(\"id\".equals(key))&#123; test.setId(Long.valueOf(map.get(key).toString())); &#125;else if(\"name\".equals(key))&#123; if(map.get(key) == null)&#123; test.setName(null); &#125;else&#123; test.setName(map.get(key).toString()); &#125; &#125;else if(\"age\".equals(key))&#123; test.setAge(Integer.parseInt((map.get(key).toString()))); &#125;else if(\"createDate\".equals(key))&#123; if(map.get(key) == null)&#123; test.setCreateDate(null); &#125;else &#123; calendar.setTimeInMillis(Long.parseLong(map.get(key).toString())); test.setCreateDate(calendar.getTime()); &#125; &#125; &#125; return test; &#125; TEST 查询createDate在 &quot;2017-05-04 10:20:00&quot; 和&quot;2017-05-04 10:30:00&quot;之间的数据pageNo 为1 pageSize 默认5123456789/** * 查询 createDate 在某个区间内 */ String date1 = \"2017-05-04 10:20:00\"; String date2 = \"2017-05-04 10:30:00\"; Date startDate = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").parse(date1); Date endDate = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").parse(date2); boolFilter.must(FilterBuilders.rangeFilter(\"createDate\").from(startDate.getTime())); boolFilter.must(FilterBuilders.rangeFilter(\"createDate\").to(endDate.getTime()));","tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://imice.me/tags/elasticsearch/"}]},{"title":"利用mysql触发器创建变更表推送数据到elasticsearch","date":"2017-05-04T03:23:26.174Z","path":"2017/05/04/mysql_elsticsearch/","text":"利用mysql触发器创建变更表推送数据到elasticsearch 需求：某项业务需要用到模糊查询，数据库用的mysql，%search%类似这样的索引无法生效，导致搜索特别吃力看到了这位老铁的利用mysql触发器创建变更表推送数据到elasticsearch原文链接：http://www.toozy.cn/mysql-trigger-elasticsearch/ 按照这个思路，决定采用elasticsearch来替代mysql提供搜索服务。 搜索了挺多mysql和elasticsearch之间数据同步的方式，这是常见的几款插件，大神总结了这几款插件的优缺点 any way,这几款插件对我帮助不大，我只需要这一块儿业务即可，有想研究的可以查看原文http://blog.csdn.net/laoyang360/article/details/51771621于是便有了如下的解决方案： 将要搜索的数据填充到elasticsearch里面并保持更新，原文列出了几种解决方案 在应用层面当出现增删改时顺便或提交到队列来更新索引。 解析mysql的binlog，来更新索引。 利用mysql的触发器来将变更信息写入一个表或外部队列来更新索引。 （1）出于不增加业务复杂度的考虑，放弃了在应用处理的方案。（2）第二种binblog方式，原文说是出于运维部署，以及对于binlog方式如何处理单表的顾虑，放弃了binlog方案，这货不是今天的主题先略过，回头再研究…（3）最后采取的是利用mysql触发器来将变更插入一张表，通过计划任务处理变更表里的数据变更表方案给要操作的表增加增删改的触发器，将变更表id写入一张change表，服务器实时读取变更表数据，同步更新elsearch对应索引。 创建增删改的触发器 一张测试表test用来模拟我们要操作的表， 一张用来保存test表记录变更的test_change表， change_type用来保存test表触发的类型，(增删改)change_id用来保存更新字段的idlaster_id 持久化一个最后更新的id标识接下来创建三个简单的触发器123456789#增加CREATE TRIGGER test_trigger_insert AFTER INSERT ON test FOR EACH ROW INSERT INTO test_change VALUES(NULL,now(),'INSERT',NEW.id,null);#修改CREATE TRIGGER test_trigger_update AFTER UPDATE ON testFOR EACH ROW INSERT INTO test_change VALUES(NULL,now(),'UPDATE',NEW.id,null);#删除CREATE TRIGGER test_trigger_delete AFTER DELETE ON testFOR EACH ROW INSERT INTO test_change VALUES(NULL,now(),'DELETE',OLD.id,null); 触发器正常的工作，记录下了变更表的操作记录 elasticsearch安装 当时装的过程中遇到不少坑… elasticsearch下载。下载完成后是一个压缩包，在需要安装的目录解压 配置环境变量path，指向elsearch目录下的bin jdk安装。。。 增加环境变量ES_HEAP_SIZE，值为：256m（或者512m）。这是分配最大和最小的存储容量。 找到bin文件夹下的elasticsearch.bat，双击运行。在bin的同级目录就会生成data和logs文件夹。执行后可以看到类似如下界面： 验证是否安装成功，在浏览器地址栏上输入：http://localhost:9200显示一串json数据，显示你的elsearch的信息12345678910111213&#123; \"status\" : 200, \"name\" : \"Arabian Knight\", \"cluster_name\" : \"elasticsearch\", \"version\" : &#123; \"number\" : \"1.4.4\", \"build_hash\" : \"c88f77ffc81301dfa9dfd81ca2232f09588bd512\", \"build_timestamp\" : \"2015-02-19T13:05:36Z\", \"build_snapshot\" : false, \"lucene_version\" : \"4.10.3\" &#125;, \"tagline\" : \"You Know, for Search\"&#125; elasticsearch插件安装 我只装了一个可视化的head插件，有其他需求可以自行安装插件安装命令：D:\\elasticsearch\\bin&gt;plugin -install mobz/elasticsearch-head安装完成后在D:\\elasticsearch\\plugins目录下会有head的文件夹打开head_site\\index.html(或者在浏览器地址栏输入http://localhost:9200/_plugin/head/),会显示如下界面： 服务器实时读取变更数据，并写入elasticsearch 获取elsearch实例12345678910&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;1.4.4&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt; &lt;/dependency&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142package com.bing.utils;import org.elasticsearch.client.transport.TransportClient;import org.elasticsearch.common.settings.ImmutableSettings;import org.elasticsearch.common.settings.Settings;import org.elasticsearch.common.transport.InetSocketTransportAddress;import java.lang.reflect.Constructor;import java.util.HashMap;import java.util.Map;/** * Created by ice on 2016/11/7. */public class EsUtil &#123; static Map&lt;String, String&gt; m = new HashMap&lt;String, String&gt;(); // 设置client.transport.sniff为true来使客户端去嗅探整个集群的状态，把集群中其它机器的ip地址加到客户端中， static Settings settings = ImmutableSettings.settingsBuilder().put(m)// .put(\"cluster.name\",\"elasticsearch\")// .put(\"client.transport.sniff\", true) .put(\"index.refresh_interval\",\"1s\")//索引自动刷新间隔时间 .build(); // 创建私有对象 private static TransportClient client; static &#123; try &#123; Class&lt;?&gt; clazz = Class.forName(TransportClient.class.getName()); Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(Settings.class); constructor.setAccessible(true); client = (TransportClient) constructor.newInstance(settings); client.addTransportAddress(new InetSocketTransportAddress(\"127.0.0.1\", 9300)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //取得实例 public static TransportClient getTransportClient() &#123; return client; &#125;&#125; 原有数据初始化 导入当前的数据至elsearch中，作为初始数据12345678910111213141516171819202122232425262728293031323334353637/** * 初始化数据 */ @Override public void init() &#123; /** * 设置字段类型 * 为什么需要设置字段类型？ * elasticSearch对字符串有两种完全不同的搜索方式， * （1）按照整个文本进行匹配，即我们平时用的关键词搜索(keyword search) * （2）按单个字符匹配，即全文搜索(full-text search) * 对ElasticSearch稍有了解的人都知道, 前者的字符串被称为 not-analyzed 字符, 而后者被称作 analyzed 字符串. * 我的需求只是简单的关键词搜索，用不到分词啥的所以要设置字段类型为String * 注：在新的elaeticsearch5.0中，String类型已被移除，增加了两个类型 * keyword 类型对应关键词搜索 ， text 类型对应全文搜索 */ //创建索引 EsUtil.getTransportClient().admin().indices().prepareCreate(\"test\").execute(); try &#123; XContentBuilder builder = XContentFactory.jsonBuilder().startObject().startObject(\"properties\") .startObject(\"id\").field(\"type\",\"long\").endObject() .startObject(\"name\").field(\"type\",\"string\").field(\"index\",\"not_analyzed\").endObject() .startObject(\"createDate\").field(\"type\",\"string\").field(\"index\",\"not_analyzed\").endObject() .startObject(\"age\").field(\"type\",\"long\").endObject() .endObject().endObject(); PutMappingRequest putMappingRequest = Requests.putMappingRequest(\"test\").type(\"testInfo\").source(builder); EsUtil.getTransportClient().admin().indices().putMapping(putMappingRequest).actionGet(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //初始化索引数据 List&lt;Test&gt; testList = testRepository.findAll(); for (Test test : testList) &#123; this.add(String.valueOf(test.getId())); &#125; &#125; 数据初始化之后打开我们的head视图http://localhost:9200/_plugin/head/可以看到我们的索引创建成功，浏览一下数据 向elsearch中插入数据123456789101112131415/** * 新增索引数据 * @param testId */ @Override public void add(String testId) &#123; Test test = testRepository.findOne(Long.valueOf(testId)); Map&lt;String,Object&gt; source = new HashMap&lt;String,Object&gt;(); source.put(\"id\",test.getId()); source.put(\"name\",test.getName()); source.put(\"createDate\",test.getCreateDate().getTime()); source.put(\"age\",test.getAge()); EsUtil.getTransportClient().prepareIndex(\"test\",\"testInfo\",testId) .setSource(source).execute().actionGet(); &#125;&gt;保存日期数据时，我保存的是毫秒数，方便后续利用elsearch的javaAPI根据日期进行查询&gt;（因为es默认存储时间的格式是UTC时间，如果我们查询es然后获取时间日期默认的数据，会发现跟当前的时间差8个小时，格式也是形如这样的1970-01-01T00:00:00Z，当然也可以直接设置format为你想要的格式，比如yyyy-MM-dd HH:mm:ss 然后存储的时候，指定格式，并且 Mapping 也是指定相同的format）从elsearch中删除数据12345678/** * 删除索引数据 * @param testId */ @Override public void del(String testId) &#123; EsUtil.getTransportClient().prepareDelete(\"test\",\"testInfo\", testId).execute().actionGet(); &#125;轮询数据库 相当于实时监听数据库，关于这个有很多方案，我这里的搜索功能对即时要求不太高，就用简单的轮询，时间间隔设置不要太短就行，以免服务器压力过大比如说我用spring的@Scheduled1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.bing.controller;import com.bing.domain.student.TestChange;import com.bing.repository.TestChangeRepository;import com.bing.repository.TestRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;/** * Created by ice on 2017/4/28. */@Controller@RequestMapping(\"/test\")public class TestChangeController &#123; @Autowired TestChangeRepository testChangeRepository; @Autowired TestRepository testRepository; @Scheduled(cron = \"0/2 * * * * ?\") public void task()&#123; Integer n =0; TestChange tc = null; if(testChangeRepository.findAll().size() &gt; 0)&#123; tc = testChangeRepository.findAll().get(0); &#125; //最后更新id标识 Integer count = testChangeRepository.getCountAsSql(); if(tc != null)&#123; n = tc.getLasterId(); &#125; count = count==null?0:count; n = n==null?0:n; if(count &gt; n )&#123; //循环的次数count-n for (int i = (n+1);i&lt;=count; i++) &#123; TestChange testChange = testChangeRepository.findOne(Long.valueOf(i)); Long changeId = Long.valueOf(testChange.getChangeId()); String chanType = testChange.getChangeType(); if(\"DELETE\".equals(chanType))&#123; //根据id从elasticsearch中删除对应数据 testChangeRepository.del(String.valueOf(changeId)); &#125;else if(\"INSERT\".equals(chanType))&#123; //向elsearch中添加数据 testChangeRepository.add(String.valueOf(changeId)); &#125;else if(\"UPDATE\".equals(chanType))&#123; //因为我们不知道要更改的属性， // 数据更新的时候只有把elsearch中原本对应的数据删除，再添加新的数据 testChangeRepository.del(String.valueOf(changeId)); testChangeRepository.add(String.valueOf(changeId)); &#125; &#125; &#125; n = count; if(tc != null)&#123; tc.setLasterId(n); testChangeRepository.save(tc); &#125; &#125; @RequestMapping(\"/init\") public void init()&#123; testChangeRepository.init(); &#125;&#125; 测试 基本配置已经完成，可以手动更改数据库中的数据来测试是否会同步到elasticsearch 接下来就是调用elsearch的javaapi来做数据查询，恩就放到下一篇吧。。。","tags":[{"name":"mysql","slug":"mysql","permalink":"http://imice.me/tags/mysql/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://imice.me/tags/elasticsearch/"}]},{"title":"手机端页面下滑异步加载数据","date":"2017-04-27T02:27:32.310Z","path":"2017/04/27/slideLoading/","text":"手机端页面下滑异步加载数据 需求：手机端滑动异步加载产品数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//当前pageNovar pageNo = parseInt('$&#123;pageNo&#125;');$(function()&#123; query('first');//首次加载&#125;);//设置加载状态var loading = false;Zepto(function($)&#123; $(window).scroll(function () &#123; //默认滑动到底部开始 if(($(window).scrollTop() + $(window).height() &gt; $(document).height()-10) &amp;&amp; loading )&#123; loading=false; pageNo++; query(\"then\"); &#125; &#125;);&#125;);function query(type)&#123; var url = \"$&#123;ctx&#125;/product/getJson.action?pageNo=\"+pageNo; $loading.show();//显示加载中效果 $.ajax(&#123; url:url, success:function()&#123; loading = true;//标识 if(data == null)&#123; pageNo--; $.loading.hide(); $('.nomore-products').show();//数据加载完成，无更多 loading = false; &#125;else&#123; if(type == 'then')&#123;//滑动加载 if(data.length == 0)&#123; pageNo--; $loading.hide(); $('.nomore-products').show(); loading = false; return \"\"; &#125; &#125; $.each(data,function(i,item)&#123; //获取json数据拼接html $productList.append( '&lt;figcaption&gt;' +'&lt;span&gt;' + item.productTitle + '&lt;/span&gt;' +'&lt;span&gt;' + item.productId+ '&lt;/span&gt;' +'&lt;/figcaption&gt;' ); $loading.hide(); &#125;); &#125; &#125;, error:function(XMLHttpRequest,textStatus,errorThrown)&#123; loading=true; pageNo--; alert(\"数据加载出错\"+textStatus); &#125; &#125;); 如果首次加载不想用异步方式，可以在pageNo声明之后直接++，直接加载第二页，首次可以用从后台直接返回的list数据，异步加载时再返回json即可","tags":[{"name":"滑动异步加载","slug":"滑动异步加载","permalink":"http://imice.me/tags/滑动异步加载/"}]},{"title":"正则表达式匹配url","date":"2017-04-13T10:16:31.934Z","path":"2017/04/13/zhengze/","text":"正则表达式匹配url 需求：在客户端识别一段文字中的url并加上链接效果 12345678&lt;script type=\"text/javascript\"&gt; function replaceReg(reg,str)&#123; return str.replace(reg,function(m)&#123;return '&lt;a href=\"http://'+m+'\" target=\"_blank\"&gt;'+m+'&lt;/a&gt;';&#125;) &#125; var reg = /[\\w\\-]+(\\.[\\w\\-]+)+([\\w\\-\\.,@?^=%&amp;:\\/~\\+#]*[\\w\\-\\@?^=%&amp;\\/~\\+#])?/ig; var str ='普通ice1025.github.io前缀http://ice1025.github.io带参数https://ice1025.github.io/2017/04/05/categories_%20java/复杂参数https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;tn=baidu&amp;wd=test&amp;oq=ice1025.github.io&amp;rsv_pq=aff940260000ac5b&amp;rsv_t=7296ebK9LCPPnnupMO6dFV7jFM9hTjiVM24P3ETj4%2BH%2F3W%2BPlK0wix6RqS4&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug3=12&amp;rsv_sug1=12&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;inputT=4695&amp;rsv_sug4=4695'; document.write(replaceReg(reg,str));&lt;/script&gt; 可以看到这里正则开头并没有限制以https | http | ftp开头，而是在输出时添加http://原因： 通过正则中 | + space确实可以匹配到类似www.xx.com这种网址但是我发现点击跳转的时候 target 失效，形成 localhost/www.xx.com 这种网址 页面效果如图： 头部选择不匹配，如有需要可以在头部加上((ht|f)tps?):\\/\\/","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://imice.me/tags/正则表达式/"}]}]